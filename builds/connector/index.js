"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _Connection=_interopRequireDefault(require("./lib/Connection")),_package=_interopRequireDefault(require("../package.json")),_Tracing=_interopRequireDefault(require("../utils/Tracing")),_Result=_interopRequireDefault(require("../utils/Result")),_Utils=_interopRequireDefault(require("../utils/Utils")),_nodeFetch=_interopRequireDefault(require("node-fetch"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}class Connector{constructor(a){try{this._name=a,this._connector=_Connection.default.getInstance()}catch(a){throw _Tracing.default.error(_package.default.name,"Error occured in "+this._name+" table"),a}}static async migration(a){let b=_Connection.default.getInstance(),c=await(0,_nodeFetch.default)("https://raw.githubusercontent.com/intendantio/intendant/main/migration/index.json"),d=await c.json(),e=await b.prepare("SELECT * FROM metadata WHERE reference=@reference").get({reference:"database"});if(!1==e.data)_Tracing.default.error(_package.default.name,"Error configuration in version is missing");else{let c=d.last,f=parseInt(e.value),g=c-f;if(_Tracing.default.verbose(_package.default.name,g+" update(s) is available"),0==g)a();else if(0<g){let c=d.versions[f+1];if(_Utils.default.isCompatible(_package.default.version,c.core)){let d=await(0,_nodeFetch.default)(c.url);if(200==d.status){let c=await d.text(),e=c.split(";");for(let a,c=0;c<e.length;c++)a=e[c].replace("\n",""),""!=a&&(await b.prepare(a).run());_Tracing.default.verbose(_package.default.name,"Migration success version n\xB0"+(f+1)),await this.migration(a)}}else _Tracing.default.warning(_package.default.name,"Core must have a minimum version of "+c.core+" to accept the update"),a()}else 0>g&&_Tracing.default.error(_package.default.name,"Invalid version")}}check(a){!1==this._connector.open?(_Tracing.default.error(_package.default.name,"Unable to connect at database "+this._name),_Tracing.default.error(_package.default.name,"Please check the configuration of the connector and the status of the database"),process.exit(0)):this._connector.inTransaction&&setTimeout(()=>{_Tracing.default.pure("In transaction"),this.check(a)},2e3)}async getOne(a){this.check("getOne");try{let b=await this._connector.prepare("SELECT * FROM "+this._name+" WHERE id=@id").get({id:a});return new _Result.default(_package.default.name,!1,"",!!b&&b)}catch(a){return _Tracing.default.error(_package.default.name,"Catch Sqlite error on "+this._name+" : "+a.toString()),new _Result.default(_package.default.name,!0,"Error occurred when get one "+this._name)}}async getOneByField(a){if(this.check("getOneByField"),"object"==typeof a)try{let b=await this._connector.prepare("SELECT * FROM "+this._name+this.getWhere(a)).get(a);return new _Result.default(_package.default.name,!1,"",!!b&&b)}catch(a){return _Tracing.default.error(_package.default.name,"Catch Sqlite error on "+this._name+":getOneByField : "+a.toString()),new _Result.default(_package.default.name,!0,"Error occurred when get one by field "+this._name)}else return _Tracing.default.warning("Wheres must be an object at "+this._name+":getOneByField"),new _Result.default(_package.default.name,!0,"Wheres must be an object at "+this._name+":getOneByField")}async getAllByField(a={}){if(this.check("getAllByField"),"object"==typeof a)try{let b=await this._connector.prepare("SELECT * FROM "+this._name+this.getWhere(a)).all(a);return new _Result.default(_package.default.name,!1,"",b)}catch(a){return _Tracing.default.error(_package.default.name,"Catch Sqlite error on "+this._name+":getAllByField : "+a.toString()),new _Result.default(_package.default.name,!0,"Error occurred when get all by field "+this._name)}else return _Tracing.default.warning("Wheres must be an object at "+this._name+":getAllByField"),new _Result.default(_package.default.name,!0,"Wheres must be an object at "+this._name+":getAllByField")}async count(a={}){if(this.check("count"),"object"==typeof a)try{let b=await this._connector.prepare("SELECT * FROM "+this._name+this.getWhere(a)).all(a);return new _Result.default(_package.default.name,!1,"",{count:b.length})}catch(a){return _Tracing.default.error(_package.default.name,"Catch Sqlite error on "+this._name+":count : "+a.toString()),new _Result.default(_package.default.name,!0,"Error occurred when get all by field "+this._name)}else return _Tracing.default.warning("Wheres must be an object at "+this._name+":count"),new _Result.default(_package.default.name,!0,"Wheres must be an object at "+this._name+":count")}async getAll(){this.check("getAll");try{let a=await this._connector.prepare("SELECT * FROM "+this._name).all();return new _Result.default(_package.default.name,!1,"",a)}catch(a){return _Tracing.default.error(_package.default.name,"Catch Sqlite error on "+this._name+":getAll : "+a.toString()),new _Result.default(_package.default.name,!0,"Error occurred when get all "+this._name+":getAll")}}async deleteOne(a){this.check("deleteOne");try{return await this._connector.prepare("DELETE FROM "+this._name+" WHERE id=@id").run({id:a}),new _Result.default(_package.default.name,!1,"")}catch(a){return _Tracing.default.error(_package.default.name,"Catch Sqlite error on "+this._name+":deleteOne : "+a.toString()),new _Result.default(_package.default.name,!0,"Error occurred when delete on "+this._name+":deleteOne")}}async deleteAllByField(a){if(this.check("deleteAllByField"),"object"==typeof a)try{return await this._connector.prepare("DELETE FROM "+this._name+this.getWhere(a)).run(a),new _Result.default(_package.default.name,!1,"")}catch(a){return _Tracing.default.error(_package.default.name,"Catch Sqlite error on "+this._name+":deleteAllByField : "+a.toString()),new _Result.default(_package.default.name,!0,"Error occurred when delete all by field "+this._name)}else return _Tracing.default.warning("Wheres must be an object at "+this._name+":deleteAllByField"),new _Result.default(_package.default.name,!0,"Wheres must be an object at "+this._name+":deleteAllByField")}async updateAll(a={},b={}){if(this.check("updateAll"),"object"==typeof b&&"object"==typeof a)try{let c={};for(let b in a){let d=a[b];c["set"+b]=d}for(let a in b){let d=b[a];c["where"+a]=d}return await this._connector.prepare("UPDATE "+this._name+this.getSet(a,"set")+this.getWhere(b,"where")).run(c),new _Result.default(_package.default.name,!1,"")}catch(a){return _Tracing.default.error(_package.default.name,"Catch Sqlite error on "+this._name+":updateAll : "+a.toString()),new _Result.default(_package.default.name,!0,"Error occurred when update all "+this._name)}else return _Tracing.default.warning("Wheres or Sets must be an object at "+this._name+":updateAll"),new _Result.default(_package.default.name,!0,"Wheres or Sets must be an object at "+this._name+":updateAll")}async truncate(){this.check("truncate");try{return await this._connector.prepare("DELETE FROM "+this._name).run(),new _Result.default(_package.default.name,!1,"")}catch(a){return _Tracing.default.error(_package.default.name,"Catch Sqlite error on "+this._name+":truncate : "+a.toString()),new _Result.default(_package.default.name,!0,"Error occurred when truncate "+this._name)}}async insert(a){if(this.check("insert"),"object"==typeof a)try{let b=await this._connector.prepare("INSERT INTO "+this._name+" "+this.getInsert(a)).run(a);return b={insertId:b.lastInsertRowid},new _Result.default(_package.default.name,!1,"",b)}catch(a){return _Tracing.default.error(_package.default.name,"Catch Sqlite error on "+this._name+":insert : "+a.toString()),new _Result.default(_package.default.name,!0,"Error occurred when insert "+this._name)}else return _Tracing.default.warning("Sets must be an object at "+this._name+":insert"),new _Result.default(_package.default.name,!0,"Sets must be an object at "+this._name+":insert")}async execute(a,b={}){if(this.check("execute"),"string"==typeof a)try{a=a.replace("DATE:NOW","date('now')");let c=!1;return c=b.run?await this._connector.prepare(a).run():await this._connector.prepare(a).all(),{package:_package.default.name,error:!1,data:c,message:""}}catch(a){let b=this._name+" catch an error : "+a.toString();return _Tracing.default.error(_package.default.name,b),{error:!0,package:_package.default.name,message:b}}else return{package:_package.default.name,message:"Invalid parameter "+this._name,error:!0}}getWhere(a,b=""){let c=0,d=" WHERE ";for(let e in a)0<c&&(d+=" AND "),d=d+e+"=@"+b+e,++c;return 0===c?"":d}getSet(a,b=""){let c=0,d=" SET ";for(let e in a)0<c&&(d+=" , "),d=d+e+"=@"+b+e,++c;return 0===c?"":d}getInsert(a){let b=0,c="(",d="(";for(let e in a)0<b&&(c+=",",d+=","),d+=e,c=c+"@"+e,++b;return c+=")",d+=")",d+" VALUES "+c}}var _default=Connector;exports.default=_default,module.exports=exports.default;